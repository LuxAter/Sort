\documentclass{article}

\usepackage{multicol}
\usepackage{xcolor}
\usepackage{listings}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},
  basicstyle=\footnotesize,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  commentstyle=\color{mygreen},
  deletekeywords={...},
  escapeinside={\%*}{*)},
  extendedchars=true,
  frame=single,
  keepspaces=true,
  keywordstyle=\color{blue},
  language=C++,
  numbers=left,
  numberstyle=\tiny\color{mygray},
  rulecolor=\color{black},
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  stepnumber=1,
  stringstyle=\color{mymauve},
  tabsize=2,
  title=\lstname
}
\usepackage{algpseudocode}
\usepackage[toc,page]{appendix}
\usepackage{pgfplots}
\pgfplotsset{width=10cm,compat=1.9}

\title{Comparison of Sorting Algorithms}
\date{19-11-2016}
\author{Arden Rasmussen}

\begin{document}
\pagenumbering{gobble}
\maketitle
\newpage
\tableofcontents
\newpage
\pagenumbering{arabic}
\begin{abstract}
This project aims to compare and contrast the some commonly used sorting algorithms. The different sorting algorithms that will be tested will be tested on value range, and value size, in order to determine the best and worst case scenarios for each algorithm.
\end{abstract}
\section{Introduction}
\subsection{Terms}
This is a set of standard terms and variables that will be referenced to for explanations of the sorting algorithms, and their methods.

$n:$ The number of values that will be sorted by the sorting algorithms.

$r:$ The range for $n$ that will be sorted.

$Values:$ The stored values to be sorted, of $n$ length, and in $r$ range.

$t:$ The time in seconds that an algorithm takes to sort $n$ values.

$(i)$ Reference to specific line in referenced code example.

\newpage
\section{Algorithms}
Here is a description of the algorithms that were a part of this research. In this section each algorithm will be described, and the method of its sorting will be explained in words, as well as with persudo code.
\newpage


\subsection{Bubble Sort}
\begin{multicols}{2}
Bubble sort works off of a method where the algorithm only focus on a two terms of the list at a time. Bubble sort compares two adjacent pairs of numbers, and switches them to be in the correct order. The algorithm moves through the list until it reaches the end. However, this does not mean that the list is sorted, so the algorithm returns to the beginning and repeats the loop switching items when necessary until there are no more items that need to be switched.

This method can then be optimized through several methods. One optimization method that is implemented in this example is setting a limit to the maximum on the loop. If there are no more values that need to be swapped, then the algorithm does not need to continue to check those values. So simply the algorithm can track a limit to the maximum value that needs to be checked, and instead of looping through the entire list of values, the algorithm can loop through a select number of the values from the lists.

Here is an example of the persudo code, followed by a line by line explanation of the code. A example of bubble sort in actual code can be found in \ref{code:bubble}.
\end{multicols}
\begin{algorithmic}
\Function{BubbleSort}{$Values$}
\State $n=$length($Values$)
\While {$n\neq0$}
\State $newn=0$
\For {$i=1$ to $n-1$}
\If{$Values[i-1]>Values[i]$} 
\State Swap$(Values[i-1]$, $Values[i])$
\State $newn=i$
\EndIf
\EndFor
\State $n=newn$
\EndWhile
\EndFunction
\end{algorithmic}
\begin{multicols}{2}
$(1)$ The definition of the function with an input of $Values$ which is a list of values to be sorted.

$(2)$ The beginning of a loop the follow until $Values$ is completely sorted.

$(3)$ The definition of $newn$ variable which will be used to determine the maximum limit on the sorting loop.

$(4)$ The for loop that begins at the first two items in $Values$ and ends at the $n-1$ item in $Values$.

$(5)$ The if check to determine if the two items need to be switched.

$(6)$ Swaps the two compared items positions.

$(7)$ Sets $newn$ to $i$ in order to move the upper limit up to the current maximum necessary swap position.

$(10)$ Sets $n$ to $newn$ essentially setting the upper limit on  the for loop.
\end{multicols}
\begin{multicols}{2}
Bubble sort is considered a very poor method for sorting algorithms, and is most often less efficient than other extremely simple sorting algorithms. Bubble sort has a complexity of $O(n^2)$. This complexity means that for an increase in the $n$, the complexity of the algorithm, and the time requirement grow exponentially. For small $n$ values this algorithm would work sufficiently, but as the number of values grows this algorithm becomes much less efficient, and soon becomes useless.
\end{multicols}


\subsection{Bucket Sort}
\begin{multicols}{2}
Bucket sort works with a method of dividing the set of values into smaller and smaller sub groups. The algorithm creates a set of "buckets" that it then sorts the values into. This method can be simplified as sorting groups at a time. For example any values that are in the first $10\%$ will be placed in the first bucket, then values in the second $10\%$ will be placed in the second bucket. This continues until all values have been placed into a bucket. Then the algorithm is run again with each of the bucket that were just created as the main bucket. Each of the terms that was placed in the first bucket are then again sorted into ten more buckets. This is done until all values are in their own bucket. Then the buckets are placed back together in order. This results in the sorted list of values.

Bucket sort can as well be optimized. Bucket sort is very effective at breaking up the large data set into smaller semi-sorted sets of data, but at a point bucket sort becomes inefficient. Because going through algorithm until every value has its own bucket requires much more calculations than some optimized algorithms. One such optimization is to use bucket sort, then once the number of elements in a bucket is below a specified level, then that bucket is sorted using some other sorting algorithm. Or another option is to place all the buckets back into a single semi-sorted list, and then use \textit{Insertion Sort} to complete the sorting, because \textit{Insertion Sort}'s runtime is based off of an elements distance from its final position.

Here is bucket sort code in persudo code, accompanied with a line by line explanation. Real examples of code can be found in \ref{code:bucket}.
\end{multicols}
\begin{algorithmic}
\Function{BucketSort}{$Values$, $n$}
\State $Arrays<-$ new array of $n$ empty lists
\For{$i=0$ to (length($Values$)-1)}
\State insert $Values[i]$ into $Arrays[$floor($Values[i]$/(rangeof($Values$)/$n$))$]$
\EndFor
\State clear $Values$
\For{$i=0$ to $n-1$}
\State append \Call{BucketSort}{$Arrays[i]$, $n$} to $Values$
\EndFor
\State \Return $Values$
\EndFunction
\end{algorithmic}
\begin{multicols}{2}
$(1)$ The definition of the function with an input of $Values$ which is a list of values to be sorted, and $n$ which is the number of buckets to sort into.

$(2)$ Creates a new list of $n$ empty list or "buckets".

$(3)$ Beginning of a for loop that goes through the length of $Values$ and sorts them into the $Arrays$.

$(4)$  The method used for determining what $Array$ to place the item into is done by dividing the value of the item by the value range of the array, then rounding down. This will result in returning the correct $Array$ for the item to be sorted into.

$(6)$ Clears $Values$ of any items to prepare it for rewriting with sorted results.

$(7)$ Beginning of a for loop that goes through every list in $Arrays$

$(8)$ Recursively calls bucket sort with each new list of items that was placed in each bucket. Eventually there will only be a single item in a bucket and it cannot be sorted. The returned results will be appended together into a complete and sorted list of values.

$(10)$ This sorted list of values is then returned for any functions higher up in the chain of being called in the recursive function.
\end{multicols}
\begin{multicols}{2}
Bucket sort is a moderately effective sorting algorithm, but could be greatly improved with some simple optimizations. On its own Bucket sort has a complexity of $O(n)$, as there is a need for a bucket for every element that is being sorted. This means that it is fairly efficient, but still could be greatly improved by the implementation of a limit for the minimum size of bucket before initiation a different sorting algorithm.
\end{multicols}

\subsection{Cocktail Sort}
\begin{multicols}{2}
Cocktail Sort uses a method similar to bubble sort. However one improvement that Cocktail sort makes over bubble sort is that the algorithm of cocktail sort goes both ways through the list of items. Bubble sort can only move the items up the the correct position, but cocktail sort is able to also move items down in the list, so the terms are sorted from both directions at the same time.

Here is the persudo code for an example of Cocktail sort, accompanied with a line by line explanation. Real examples of code can be found in \ref{code:cocktail}.
\end{multicols}
\begin{algorithmic}
\Function{CocktailSort}{$Values$}
\State $Swapped=true$
\State $Start=0$
\State $End=$length($Values$)$-1$
\While{$Swapped=true$}
\State $Swapped=false$
\For{$i=Start$ to $End$}
\If{$Values[i-1]>Values[i=1]$} 
\State Swap$(Values[i]$, $Values[i+1])$
\State $Swapped=true$
\EndIf
\EndFor
\If{$Swapped=false$}
\State $break$
\EndIf
\State $Swapped=false$
\State $End-1$
\For{$i=End$ to $Start$}
\If{$Values[i]>Values[i+1]$} 
\State Swap$(Values[i]$, $Values[i+1])$
\State $Swapped=true$
\EndIf
\EndFor
\State $Start+1$
\EndWhile
\EndFunction
\end{algorithmic}
\begin{multicols}{2}
$(1)$ The definition of the function with an input of $Values$ which is a list of values to be sorted.

$(2)$ Creates variables storing the beginning and end of the sort range.

$(5)$ Beginning of a while loop that runs until $Values$ is sorted.

$(7)$  Basic Bubble sort for loop, moving one item up to its final position.

$(13)$ Checks if nothing was moved, which would mean that $Values$ is sorted.

$(17)$ Reduces $End$ by one, because that item is correctly sorted.

$(18)$ Second Bubble sort loop, but traveling backwards through $Values$

$(24)$ Increases $Start$ by one, because that item is correctly sorted.
\end{multicols}
\begin{multicols}{2}
Cocktail sort is considered a very poor method for sorting algorithms, and is most often less efficient than other extremely simple sorting algorithms. Cocktail sort has a complexity of $O(n^2)$. This complexity means that for an increase in the $n$, the complexity of the algorithm, and the time requirement grow exponentially. For small $n$ values this algorithm would work sufficiently, but as the number of values grows this algorithm becomes much less efficient, and soon becomes useless.
\end{multicols}


\subsection{Counting Sort}
\begin{multicols}{2}
Counting Sort uses a method where the algorithm counts the number of elements with the same value. Counting sort goes through all the elements in the list, and creates counters for each value in the element list range. The algorithm then goes through the list and adds to each respective counter for each element. Once all the counters are created, then the final list of elements is created by adding each counter to the list. This means that this algorithm is extremely memory efficient with data sets that have a small range, as the algorithm only needs to store a list of range number of integers. However when the data set has a wide range, then this algorithm becomes much less efficient, as there will be many unused counters, and will require storing many more values. This algorithm is very efficient for time, but for memory the algorithms complexity quickly grows, causing it to be unmanageable for data sets with a wide range of values.

This algorithm can be optimized by reducing the  number of for loops that are necessary, and limiting the counters to a lower and upper bound. Because if the values in a list  begin until sever hundred, there is no reason to store counters for everything up until then.

Here is Counting sort code in persudo code, accompanied with a line by line explanation. Real examples of code can be found in \ref{code:counting}.
\end{multicols}
\begin{algorithmic}
\Function{CountingSort}{$Values$}
\State $Counters<-$ an array of integer values
\State $min<-$ integer for smallest value in $Values$
\State $max<-$ integer for largest value in $Values$
\For{$i=0$ to length($Values$) - 1}
\If{$Values[i]>max$}
\State $max=Values[i]$
\EndIf
\If{$Values[i]<min$}
\State $min=Values[i]$
\EndIf
\EndFor
\For{$i=min$ to $max$}
\State append $0$ to $Counters$
\EndFor
\For{$i=0$ to length($Values$) - 1}
\State $Counters[values[i]-min] + 1$
\EndFor
\State Clear $Values$
\For{$i=0$ to length($Counters$) - 1}
\For{$j=0$ to $Counters[i]$}
\State append $(i+min)$ to $Values$
\EndFor
\EndFor
\EndFunction
\end{algorithmic}
\begin{multicols}{2}
$(1)$ The definition of the function with an input of $Values$ which is a list of values to be sorted.

$(5)$ For loop used to determine the minimum and maximum values in $Values$.

$(13)$ For loop to create counters for each value from $min$ to $max$

$(16)$ For loop that runs through all elements in $Values$ and adds to each respective counter for each value.

$(19)$ Clears $Values$ of any items to prepare it for rewriting with sorted results.

$(20)$ Beginning of a for loop that goes through every counter in $Counters$

$(21)$ For loop that adds the counted number of each element back into $Values$ based off of $Counters$
\end{multicols}
\begin{multicols}{2}
Counting sort is extremely efficient in terms of time, as there is no actual comparison between the different elements in the list. This means that counting sort runs fairly quickly, but the memory necessary grows with the range of elements. For a list of elements that has a small range, counting sort will be extremely effective, but for a list of elements with a large range of elements, counting sort will require much more memory to run. The complexity of counting sort is $O(n+k)$, where $k$ is the range of values. This is true for the best and worst case scenarios for counting sort, making it an extremely predictable sorting algorithm.
\end{multicols}
\subsection{Heap Sort}
\subsection{Insertion Sort}
\begin{multicols}{2}
Insertion sort is a very common sorting algorithm, as it is very simple, and still effective. The method of insertion sort is to select the first value in the list, and to then check it against every value after it in the list. If the selected value is greater than the other value in the comparison, then the two values are switched, otherwise the loop stops.
\end{multicols}
\subsection{Merge Sort}
\subsection{Quick Sort}
\subsection{Radix Sort}
\subsection{Selection Sort}
\subsection{Shell Sort}
\subsection{Tim Sort}
\subsection{Tree Sort}


\newpage
\begin{appendices}
\section{Algorithms}
\subsection{Bubble}
\label{code:bubble}
\subsubsection{C++}
\lstinputlisting[language=C++]{algorithms/bubble/bubble_sort.cpp}
\newpage
\subsection{Bucket}
\label{code:bucket}
\subsubsection{C++}
\lstinputlisting[language=C++]{algorithms/bucket/bucket_sort.cpp}
\newpage
\subsection{Cocktail}
\label{code:cocktail}
\subsubsection{C++}
\lstinputlisting[language=C++]{algorithms/cocktail/cocktail_sort.cpp}
\newpage
\subsection{Counting}
\label{code:counting}
\subsubsection{C++}
\lstinputlisting[language=C++]{algorithms/counting/counting_sort.cpp}
\newpage
\subsection{Insertion}
\label{code:insertion}
\subsubsection{C++}
\lstinputlisting[language=C++]{algorithms/insertion/insertion_sort.cpp}
\newpage
\subsection{Merge}
\label{code:merge}
\subsubsection{C++}
\lstinputlisting[language=C++]{algorithms/merge/merge_sort.cpp}
\newpage
\subsection{Quick}
\label{code:quick}
\subsubsection{C++}
\lstinputlisting[language=C++]{algorithms/quick/quick_sort.cpp}
\newpage
\subsection{Selection}
\label{code:selection}
\subsubsection{C++}
\lstinputlisting[language=C++]{algorithms/selection/selection_sort.cpp}
\end{appendices}
\end{document}