\documentclass{subfile}
\begin{document}
\subsection{Bubble Sort}\label{C:B}
\begin{align*}
  \text{Best-Case Performance}\quad &O\left(n\right)\\
  \text{Average Performance}\quad &O\left(n^{2}\right)\\
  \text{Worst-Case Performance}\quad &O\left(n^{2}\right)\\
  \text{Worst-Case Space Complexity}\quad &O\left(1\right)
\end{align*}
\begin{multicols}{2}
  Bubble sort is an algorithm that goes term by term, sorting pairs of two adjacent elements. Although the algorithm is extremely simplistic it is not very effective for arrays that are not mostly sorted already. The algorithm repeatedly steps through the list of items, and it compares each pair of adjacent elements, and swaps the two elements if they are not in order. This is repeated until no swaps are necessary. This algorithm is extremely simple, as it only considers two elements at a time.
  \par
  Bubble sorts complexity is a worst case of $O\left(n^{2}\right)$, because each element must be slowly moved into place one step at a time. This means that the algorithm takes increasingly longer to run as the number of elements to sort grows. However, bubble sort does have an advantage over more complicated sorting algorithms. This is when the list is already in sorted order. Because the algorithm contains a simple check to see if the list is sorted, when the input is already sorted bubble sort can run with a best case of $O\left( n\right)$, because it just needs to loop through the elements once to determine if it is sorted. Other more complex sorting algorithms such as Quick sort (\ref{C:Q}) are unable to do this, and so cannot run with this efficiency.
  \par
  The cayuse for bubble sorts slow worst-case run time is because of what are commonly called ``turtles''. Turtles are small elements that begin near the back of the list. Because these items can only move towards that begin once per loop, then it the smallest item is at the end of the list, it will take $n-1$ passes in order to move it all the way to the beginning of the list. In opposition to turtles, there are ``rabbits''. Rabbits are large elements, because the largest element will always be swapped back, it means that no matter where in the list it begins, it will be in place after the first pass.
  \par
  Pseudocode for the Bubble Sort algorithm is shown below in Algorithm \ref{C:B:1}. The function gets a value ($length$) for the length of the array of elements. While this value is not equal to zero, the algorithm loops through the array swapping any elements that need to be swapped. In each loops, the algorithm creates a new length value ($newLength$). This new length is set to the position in the list where the maximum swap occurs, because due to the nature of the algorithm, once there is no swapping in the upper bounds, it indicates that the upper part of the array has been sorted, and there is no need to loop through those elements unnecessarily.
  \par
  There are many variation to bubble sort that attempt to improve the run time for the algorithm, such as Cocktail Sort (\ref{C:CT}), or Comb Sort (\ref{C:C}). Source code examples of Bubble sort can be found in \ref{APENDIX:B}. 
\end{multicols}
\newpage
\begin{algorithm}
  \caption{Bubble Sort Pseudocode}\label{C:B:1}
  \begin{algorithmic}[1]
    \Function{Bubble}{$a$}
      \State $length \gets $length($a$)
      \While{$length\neq0$}
        \State $newLength \gets 0$
        \For{$i=1$ to $length-1$}
          \If{$a[i-1]>a[i]$}
            \State Swap($a[i-1]$,$a[i]$)
            \State $newLength \gets i$
          \EndIf
        \EndFor
        \State $length\gets newLength$
      \EndWhile
      \State \Return $a$
    \EndFunction
  \end{algorithmic}
\end{algorithm}
\newpage
\end{document}
